# 知情搜索算法

> 原文:[https://www.javatpoint.com/ai-informed-search-algorithms](https://www.javatpoint.com/ai-informed-search-algorithms)

到目前为止，我们已经讨论了无信息搜索算法，它在搜索空间中寻找问题的所有可能的解决方案，而没有任何关于搜索空间的额外知识。但知情搜索算法包含一系列知识，如我们离目标有多远、路径成本、如何到达目标节点等。这些知识有助于代理减少对搜索空间的探索，更有效地找到目标节点。

通知搜索算法对于大搜索空间更有用。通知搜索算法采用启发式的思想，因此也称为启发式搜索。

**启发式函数:**启发式是在知情搜索中使用的函数，它找到最有希望的路径。它将代理的当前状态作为其输入，并生成代理离目标有多近的估计。然而，启发式方法可能并不总是给出最佳解决方案，但它保证在合理的时间内找到一个好的解决方案。启发式函数估计一个状态离目标有多近。它由 h(n)表示，它计算一对状态之间的最佳路径的成本。启发式函数的值总是正的。

**启发式函数的可容许性给出为:**

```

     h(n) <= h*(n)

```

**这里 h(n)是启发式成本，h*(n)是估计成本。因此启发式成本应该小于或等于估计成本。**

## 纯启发式搜索:

纯启发式搜索是启发式搜索算法的最简单形式。它根据节点的启发值 h(n)扩展节点。它维护两个列表，开放列表和关闭列表。在封闭列表中，它放置已经展开的节点，在开放列表中，它放置尚未展开的节点。

在每次迭代中，具有最低启发式值的每个节点 n 被展开并生成其所有后继节点，n 被放入封闭列表。算法继续单元，直到找到目标状态。

在信息搜索中，我们将讨论下面给出的两种主要算法:

*   **最佳优先搜索算法(贪婪搜索)**
*   **A*搜索算法**

### 1.)最佳优先搜索算法(贪婪搜索):

贪婪最佳优先搜索算法总是选择在那个时刻出现最好的路径。它是深度优先搜索和广度优先搜索算法的结合。它使用启发式函数和搜索。最佳优先搜索允许我们利用两种算法的优势。借助最佳优先搜索，在每一步，我们都可以选择最有希望的节点。在最佳优先搜索算法中，我们扩展最接近目标节点的节点，并通过启发式函数估计最接近的代价，即

```

    f(n)= g(n). 

```

wae，h(n)=从节点 n 到目标的估计成本。

贪婪最佳优先算法由优先级队列实现。

### 最佳优先搜索算法:

*   **步骤 1:** 将起始节点放入 OPEN 列表。
*   **步骤 2:** 如果打开列表为空，则停止并返回失败。
*   **步骤 3:** 从 h(n)值最低的 OPEN 列表中删除节点 n，并将其放入 CLOSED 列表中。
*   **第四步:**展开节点 n，生成节点 n 的后继节点。
*   **第五步:**检查节点 n 的各个后继节点，看是否有节点是目标节点。如果任何后续节点是目标节点，则返回成功并终止搜索，否则继续步骤 6。
*   **步骤 6:** 对于每个后继节点，算法检查评估函数 f(n)，然后检查该节点是否已经在 OPEN 或 CLOSED 列表中。如果该节点不在两个列表中，则将其添加到打开列表中。
*   **第 7 步:**返回第 2 步。

### 优点:

*   最佳优先搜索可以通过获得两种算法的优点在 BFS 和 DFS 之间切换。
*   该算法比 BFS 和 DFS 算法更有效。

### 缺点:

*   在最坏的情况下，它可以表现为非制导深度优先搜索。
*   它会像 DFS 一样陷入循环。
*   这个算法不是最优的。

### 示例:

考虑下面的搜索问题，我们将使用贪婪的最佳优先搜索来遍历它。在每次迭代中，使用评估函数 f(n)=h(n)扩展每个节点，如下表所示。

![Informed Search Algorithms](../Images/bf4713ff7f12e31acf6764ae47a0eb14.png)

在这个搜索示例中，我们使用了两个列表，即**打开**和**关闭**列表。以下是遍历上述示例的迭代。

![Informed Search Algorithms](../Images/106a126403bdfec22c86734f805ddca1.png)

**展开 S 的节点，放入 CLOSED 列表**

**初始化:**打开【A，B】，关闭【S】

**迭代 1:** 打开[A]，关闭[S，B]

**迭代 2:** 打开【E，F，A】，关闭【S，B】
:打开【E，A】，关闭【S，B，F】

**迭代 3:** 打开【I，G，E，A】，关闭【S，B，F】
:打开【I，E，A】，关闭【S，B，F，G】

因此，最终的解决方案将是: **S - > B - > F - > G**

**时间复杂度:**贪婪最佳第一次搜索的最坏情况时间复杂度为 O(b <sup>m</sup> )。

**空间复杂度:**贪婪最佳第一搜索的最坏情况空间复杂度为 O(b <sup>m</sup> )。其中，m 是搜索空间的最大深度。

**完成:**贪婪的最佳优先搜索也是不完全的，即使给定的状态空间是有限的。

**最优:**贪婪最佳优先搜索算法不是最优的。

### 2.)A*搜索算法:

A*搜索是最常见的最佳优先搜索形式。它使用启发式函数 h(n)和代价从起始状态 g(n)到达节点 n。它结合了 UCS 和贪婪最佳优先搜索的特点，有效地解决了这个问题。A*搜索算法使用启发式函数找到通过搜索空间的最短路径。这种搜索算法扩展较少的搜索树，更快地提供最优结果。A*算法除了用 g(n)+h(n)代替 g(n)之外，与 UCS 相似。

在 A*搜索算法中，我们使用搜索启发式以及到达节点的代价。因此，我们可以将两个成本合并如下，这个总和称为**健身数**。

![Informed Search Algorithms](../Images/4da482020b09a640e1fb9652ea814902.png)

在搜索空间的每一点，只有那些 f(n)值最低的节点被展开，当找到目标节点时，算法终止。

### A*搜索的算法:

**步骤 1:** 将起始节点放入 OPEN 列表中。

**步骤 2:** 检查 OPEN 列表是否为空，如果列表为空则返回失败并停止。

**步骤 3:** 从 OPEN 列表中选择评价函数值(g+h)最小的节点，如果节点 n 为目标节点则返回成功并停止，否则

**第四步:**展开节点 n 并生成其所有后继节点，将 n 放入封闭列表。对于每个后继 n’，检查 n’是否已经在打开或关闭列表中，如果没有，则计算 n’的评估函数，并将其放入打开列表中。

**步骤 5:** 否则如果节点 n’已经处于 OPEN 和 CLOSED 状态，那么它应该被附加到反映最低 g(n’)值的后指针。

**第六步:**返回**第二步**。

### 优点:

*   A*搜索算法是比其他搜索算法更好的算法。
*   A*搜索算法是最优且完整的。
*   这个算法可以解决非常复杂的问题。

### 缺点:

*   它并不总是产生最短路径，因为它主要基于启发式和近似。
*   A*搜索算法存在一些复杂性问题。
*   A*的主要缺点是内存需求，因为它将所有生成的节点都保存在内存中，因此对于各种大规模问题来说并不实用。

### 示例:

In this example, we will traverse the given graph using the A* algorithm. The heuristic value of all states is given in the below table so we will calculate the f(n) of each state using the formula f(n)= g(n) + h(n), where g(n) is the cost to reach any node from start state. Here we will use OPEN and CLOSED list. ![Informed Search Algorithms](../Images/a5f530cf3d4f083cedebe0e98d4e6eec.png)

**解决方案:**

![Informed Search Algorithms](../Images/59f61b52ac0b1aae9f39a18ed09d3c7f.png)

**初始化:** {(S，5)}

**迭代 1:** {(S - > A，4)，(S - > G，10)}

**迭代 2:** {(S - > A - > C，4)，(S - > A - > B，7)，(S - > G，10)}

**迭代 3:** {(S - > A - > C - > G，6)，(S - > A - > C - > D，11)，(S - > A - > B，7)，(S - > G，10)}

**迭代 4** 将给出最终结果，因为 **S - > A - > C - > G** 它提供了成本为 6 的最优路径。

**需要记住的点:**

*   A*算法返回最先出现的路径，它不搜索所有剩余的路径。
*   A*算法的效率取决于启发式的质量。
*   A*算法扩展所有满足条件 f(n) 的节点

**完成:** A*算法完成只要:

*   分支因子是有限的。
*   每次行动的成本是固定的。

**最优:** A*搜索算法在满足以下两个条件时为最优:

*   **容许:**最优性要求的第一个条件是 h(n)应该是 A*树搜索的容许启发式。可接受的启发本质上是乐观的。
*   **一致性:**第二个要求的条件是一致性，仅适用于 A*图形搜索。

如果启发式函数是可接受的，那么 A*树搜索将总是找到成本最小的路径。

**时间复杂度:**a*搜索算法的时间复杂度取决于启发式函数，展开的节点数与解 d 的深度成指数关系，因此时间复杂度为 O(b^d)，其中 b 为分支因子。

**空间复杂度:**a*搜索算法的空间复杂度为 **O(b^d)**

* * *