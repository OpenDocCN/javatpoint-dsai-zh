# 无信息搜索算法

> 原文:[https://www.javatpoint.com/ai-uninformed-search-algorithms](https://www.javatpoint.com/ai-uninformed-search-algorithms)

**无信息搜索是一类以蛮力方式运行的通用搜索算法。除了如何遍历树之外，无信息搜索算法没有关于状态或搜索空间的附加信息，因此也称为盲搜索。**

**以下是各种类型的无信息搜索算法:**

1.  **广度优先搜索**
2.  **深度优先搜索**
3.  **深度受限搜索**
4.  **迭代深化深度优先搜索**
5.  **统一成本搜索**
6.  **双向搜索**

## 1.广度优先搜索:

*   广度优先搜索是遍历树或图时最常用的搜索策略。这种算法在树或图中横向搜索，因此称为广度优先搜索。
*   BFS 算法从树的根节点开始搜索，并在移动到下一级节点之前展开当前级的所有后续节点。
*   广度优先搜索算法是通用图搜索算法的一个例子。
*   使用先进先出队列数据结构实现广度优先搜索。

**优势:**

*   如果有任何解决办法，BFS 将提供一个解决办法。
*   如果给定问题有多个解决方案，那么 BFS 将提供需要最少步骤的最小解决方案。

**缺点:**

*   它需要大量内存，因为树的每一级都必须保存到内存中才能扩展到下一级。
*   如果解决方案远离根节点，BFS 需要大量时间。

### 示例:

在下面的树结构中，我们展示了使用 BFS 算法从根节点 S 到目标节点 k 的树遍历。BFS 搜索算法分层遍历，因此它将遵循虚线箭头所示的路径，遍历的路径将是:

```

S---> A--->B---->C--->D---->G--->H--->E---->F---->I---->K

```

![Uninformed Search Algorithms](../Images/0a47c18a38bc7476e61df1bc15ab1308.png)

**时间复杂度:**BFS 算法的时间复杂度可以通过在 BFS 遍历到最浅 Node 的节点数得到。其中 d=最浅解的深度，b 是每个状态下的节点。

**T(b)= 1+b<sup>2</sup>+b<sup>3</sup>+.......+ b <sup>d</sup> = O (b <sup>d</sup> )**

**空间复杂度:**BFS 算法的空间复杂度由前沿的内存大小给出，即 O(b <sup>d</sup> )。

**完备性:** BFS 是完备的，这意味着如果最浅的目标节点在某个有限的深度，那么 BFS 就会找到解。

**最优性:**如果路径成本是节点深度的非递减函数，则 BFS 最优。

## 2.深度优先搜索

*   深度优先搜索是遍历树或图数据结构的递归算法。
*   它被称为深度优先搜索，因为它从根节点开始，在移动到下一个路径之前，沿着每个路径到达其最大深度节点。
*   DFS 使用堆栈数据结构来实现。
*   DFS 算法的过程类似于 BFS 算法。

#### 注意:回溯是一种使用递归寻找所有可能解的算法技术。

**优势:**

*   DFS 需要非常少的内存，因为它只需要存储从根节点到当前节点的路径上的节点堆栈。
*   到达目标节点比 BFS 算法花费的时间少(如果它以正确的路径遍历)。

**劣势:**

*   许多州有可能会再次发生，而且无法保证找到解决方案。
*   DFS 算法进行深入的搜索，有时可能会进入无限循环。

### 示例:

在下面的搜索树中，我们显示了深度优先搜索的流程，它将遵循以下顺序:

根节点->左节点->右节点。

它将从根节点 S 开始搜索，遍历 A，然后 B，然后 D 和 E，遍历 E 后，由于 E 没有其他后继节点，仍然没有找到目标节点，它将回溯树。在回溯之后，它将遍历节点 C，然后遍历节点 G，这里它将在找到目标节点时终止。

![Uninformed Search Algorithms](../Images/ce1c9b71021ebcffd7b40ad004ad36a1.png)

**完整性:** DFS 搜索算法在有限状态空间内是完整的，因为它将扩展有限搜索树内的每个节点。

**时间复杂度:**DFS 的时间复杂度将相当于算法遍历的节点。它由下式给出:

**T(n)= 1+n<sup>2</sup>+n<sup>3</sup>+.........+ n <sup>m</sup> =O(n <sup>m</sup> )**

**其中，m=任何节点的最大深度，这可以比 d(最浅解深度)**大得多

**空间复杂度:** DFS 算法只需要存储从根节点开始的单条路径，因此 DFS 的空间复杂度相当于边缘集的大小，即为 **O(bm)** 。

**最优:** DFS 搜索算法是非最优的，因为它可能会产生大量的步骤或高成本来到达目标节点。

## 3.深度受限搜索算法:

深度受限搜索算法类似于具有预定限制的深度优先搜索。深度受限搜索可以解决深度优先搜索中无限路径的缺点。在该算法中，深度极限处的节点将被视为没有后续节点。

深度受限搜索可以在两种失败情况下终止:

*   标准故障值:表示问题没有任何解决方案。
*   截止故障值:它定义了在给定的深度限制内没有问题的解决方案。

**优势:**

深度受限搜索是内存高效的。

**缺点:**

*   深度受限搜索也有不完整的缺点。
*   如果问题有多个解决方案，这可能不是最佳方案。

### 示例:

![Uninformed Search Algorithms](../Images/ecc66b1a2a6ff2bad25a181843dbef5f.png)

**完备性:**如果解在深度极限以上，则 DLS 搜索算法完备。

**时间复杂度:**DLS 算法的时间复杂度为 **O(b <sup>ℓ</sup> )** 。

**空间复杂度:**DLS 算法的空间复杂度为 O **(bℓ)** 。

**最优:**深度受限搜索可以看作是 DFS 的特例，即使ℓ > d 也不是最优的。

## 4.均匀成本搜索算法:

均匀成本搜索是一种用于遍历加权树或图的搜索算法。当每条边的成本不同时，这种算法就开始发挥作用。均匀成本搜索的主要目标是找到一条到达累积成本最低的目标节点的路径。均匀成本搜索根据节点形成根节点的路径成本来扩展节点。它可以用来求解任何需要最优成本的图/树。优先级队列实现了一种均匀成本搜索算法。它给予最低的累积成本最大的优先权。如果所有边的路径代价相同，则均匀代价搜索等价于 BFS 算法。

**优势:**

*   均匀成本搜索是最优的，因为在每个状态下，成本最小的路径被选择。

**缺点:**

*   它不关心搜索涉及的步骤数，只关心路径开销。因此该算法可能陷入无限循环。

### 示例:

![Uninformed Search Algorithms](../Images/8175688d894610300d580a667161b320.png)

**完整性:**

均匀成本搜索是完整的，比如如果有解决方案，UCS 会找到它。

**时间复杂度:**

设 C* **为最优解**的代价， **ε** 为每一步向目标节点靠拢。那么步数就是= C*/ε+1。这里我们取+1，从状态 0 开始，到 C*/ε结束。

因此，均匀成本搜索的最坏情况时间复杂度是**O(b<sup>1+【C */ε】</sup>)/**。

**空间复杂度:**

同样的逻辑也适用于空间复杂度，所以均匀成本搜索的最坏情况空间复杂度是**O(b<sup>1+【C */ε】</sup>)**。

**最优:**

均匀成本搜索总是最优的，因为它只选择路径成本最低的路径。

## 5.迭代深度优先搜索:

迭代深化算法是离散傅立叶变换和 BFS 算法的结合。这种搜索算法找出最佳深度极限，并通过逐渐增加极限直到找到目标来实现。

该算法在一定的“深度极限”内进行深度优先搜索，每次迭代后不断增加深度极限，直到找到目标节点。

这种搜索算法结合了广度优先搜索的快速搜索和深度优先搜索的内存效率的优点。

当搜索空间较大，目标节点深度未知时，迭代搜索算法是有用的无信息搜索。

**优势:**

*   它结合了 BFS 和 DFS 搜索算法在快速搜索和内存效率方面的优势。

**缺点:**

*   IDDFS 的主要缺点是它重复了前一阶段的所有工作。

### 示例:

遵循树结构显示的是迭代深化深度优先搜索。IDDFS 算法执行各种迭代，直到没有找到目标节点。算法执行的迭代如下所示:

![Uninformed Search Algorithms](../Images/82b194ca909ea866d01dec77ad9860f0.png)

第 1 次迭代- > A
第 2 次迭代- > A、B、C
第 3 次迭代- > A、B、D、E、C、F、G
第 4 次迭代- > A、B、D、H、I、E、C、F、K、G
在第 4 次迭代中，算法会找到目标节点。

**完整性:**

如果分支因子是有限的，这个算法就是完整的。

**时间复杂度:**

假设 b 是分支因子，深度是 d，那么最坏的时间复杂度是 **O(b <sup>d</sup> )** 。

**空间复杂度:**

IDDFS 的空间复杂度将为 **O(bd)** 。

**最优:**

如果路径成本是节点深度的非递减函数，则 IDDFS 算法是最优的。

## 6.双向搜索算法:

**双向搜索算法运行两个同时进行的搜索，一个形成初始状态称为前向搜索，另一个来自目标节点称为后向搜索，以找到目标节点。双向搜索用两个小的子图代替一个单一的搜索图，其中一个从初始顶点开始搜索，另一个从目标顶点开始搜索。当这两幅图相交时，搜索停止。**

**双向搜索可以使用 BFS、DFS、DLS 等搜索技术。**

**优势:**

*   双向搜索很快。
*   双向搜索需要较少的内存

**缺点:**

*   双向搜索树的实现是困难的。
*   **在双向搜索中，要提前知道目标状态。**

### 示例:

在下面的搜索树中，应用了双向搜索算法。该算法将一个图/树分成两个子图。它从节点 1 开始向前穿越，从目标节点 16 开始向后穿越。

该算法在两个搜索相遇的节点 9 处终止。

![Uninformed Search Algorithms](../Images/833ded6362b6359f93af318ea7799993.png)

**完整性:**如果我们在两个搜索中都使用 BFS，则双向搜索完成。

**时间复杂度:**使用 BFS 双向搜索的时间复杂度为 **O(b <sup>d</sup> )** 。

**空间复杂度:**双向搜索的空间复杂度为 **O(b <sup>d</sup> )** 。

**最优:**双向搜索最优。

* * *