# FOL 中的分辨率

> 原文:[https://www . javatpoint . com/ai-一阶分辨率-逻辑](https://www.javatpoint.com/ai-resolution-in-first-order-logic)

## 解决

分辨率是一种定理证明技术，通过建立反驳证明，即矛盾证明来进行。它是由数学家约翰·艾伦·罗宾逊在 1965 年发明的。

分辨率是用的，如果有各种说法被给出，而我们需要证明那些说法的一个结论。统一是决议证明中的一个关键概念。解析是一个单一的推理规则，可以有效地对**合取范式或从句形式**进行操作。

**从句**:字面量的分离(一个原子句子)被称为**从句**。它也被称为单位从句。

**合取范式**:表示从句连词的句子称为**合取范式**或 **CNF** 。

#### 注:为了更好地理解这个话题，首先学习人工智能中的 FOL。

## 分辨率推断规则:

一阶逻辑的分解规则只是命题规则的一个提升版本。如果两个子句包含互补的文字，解析可以解析这两个子句，这两个子句被认为是分开标准化的，因此它们不共享任何变量。

![Resolution in FOL](../Images/97f11a70c8e22258fd4ca97df889c113.png)

其中 **l <sub>i</sub>** 和 **m <sub>j</sub>** 是互补文字。

这个规则也被称为**二进制解析规则**，因为它只解析两个文本。

### 示例:

我们可以解决下面给出的两个条款:

**【动物(g(x) V 爱(f(x)，x)】和【￢爱(a，b) V ￢Kills(a，b)】**

其中两个互补文字是:**love(f(x)，x)和￢love(a，b)**

这些文字可以用 unifier **θ= [a/f(x)，b/x]** 统一，它会生成一个预解子句:

**【动物(g(x)诉￢杀人(f(x)，x)】。**

## 解决步骤:

1.  事实到一阶逻辑的转换。
2.  将 FOL 语句转换为 CNF
3.  否定需要证明的陈述(矛盾证明)
4.  绘制分辨率图(统一)。

为了更好地理解上述所有步骤，我们将举一个例子，在其中我们将应用分辨率。

### 示例:

1.  约翰喜欢各种各样的食物。
2.  **苹果和蔬菜都是食物**
3.  **任何人吃的没有被杀死的东西都是食物。**
4.  **阿尼尔吃花生还活着**
5.  阿尼尔吃什么，哈利就吃什么。
    **通过决议证明:**
6.  约翰喜欢花生。

**第一步:将事实转换为 FOL**

在第一步中，我们将把所有给定的语句转换成它的一阶逻辑。

![Resolution in FOL](../Images/3bf877e0784c5a1ba44240aeef0c42de.png)

**步骤 2:将 FOL 转换为 CNF**

在一阶逻辑分辨率中，需要将 FOL 转换为 CNF，因为 CNF 形式更易于分辨率证明。

*   **消除所有隐含(→)重写**
    1.  ∀x 食品(x) V 喜欢(约翰，x)
    2.  食物(苹果)λ食物(蔬菜)
    3.  ∀x ∀y[吃(x，y)λ杀(x)] V 食物(y)
    4.  活着吃(阿尼尔，花生)
    5.  ∀x 吃(阿尼尔，x) V 吃(哈利，x)
    6.  ∀x [被杀(x) ] V 活着(x)
    7.  ∀x 活着(x) V 被杀(x)
    8.  喜欢(约翰，花生)。
*   **向内移动否定()，重写**
    1.  ∀x 食品(x) V 喜欢(约翰，x)
    2.  食物(苹果)λ食物(蔬菜)
    3.  ∀x ∀y 吃被杀死的食物
    4.  活着吃(阿尼尔，花生)
    5.  ∀x 吃(阿尼尔，x) V 吃(哈利，x)
    6.  ∀x 被杀(x)v 活着(x)
    7.  ∀x 活着(x) V 被杀(x)
    8.  喜欢(约翰，花生)。
*   **重命名变量或标准化变量**
    1.  ∀x 食品(x) V 喜欢(约翰，x)
    2.  食物(苹果)λ食物(蔬菜)
    3.  ∀y ∀z 吃被杀死的食物
    4.  活着吃(阿尼尔，花生)
    5.  ∀w 吃东西
    6.  ∀g 被杀(g)v 活着(g)
    7.  ∀k 活着(k) V 被杀(k)
    8.  喜欢(约翰，花生)。
*   **通过消去法消除存在性实例化量词。**
    在这一步中，我们将消除存在量词∃，而这个过程被称为**目的论化**。但是在这个例子中，因为没有存在量词，所以在这个步骤中所有的语句都保持不变。
*   **去掉通用量词。**
    在这一步我们将去掉所有的通用量词，因为所有的语句都不是隐式量化的，所以我们不需要它。
    1.  食物(x) V 喜欢(约翰，x)
    2.  食物(苹果)
    3.  食物(蔬菜)
    4.  吃被杀死的食物
    5.  吃东西(阿尼尔，花生)
    6.  活着(阿尼尔)
    7.  吃东西(阿尼尔，w) V 吃东西(哈利，w)
    8.  被杀(g) V 活着(g)
    9.  活着(k) V 被杀(k)
    10.  喜欢(约翰，花生)。

#### 注:语句“食物(苹果)λ食物(蔬菜)”和“吃东西(阿尼尔，花生)λ活着(阿尼尔)”可以写成两个单独的语句。

*   **在析取上分布连词∧。**
    这一步不会对这个问题做出任何改变。

**第三步:否定待证语句**

在这个陈述中，我们将否定应用于结论陈述，这些结论陈述将被写成喜欢(约翰，花生)

**第 4 步:绘制分辨率图:**

现在在这一步中，我们将通过使用替换的解析树来解决这个问题。对于上述问题，将给出如下:

![Resolution in FOL](../Images/ba4d03504b852a31c234384dc077d593.png)

因此，结论的否定被证明是与给定的一组陈述完全矛盾的。

## 分辨率图的解释:

*   在解析图的第一步中，**赞(John，花生米)**、**赞(John，x)** 通过替换**{花生米/x}** 得到解析(取消)，剩下**食物(花生米)**
*   在解析图的第二步中，**食物(花生)**、**食物(z)** 通过替换 **{花生/z}** 得到解析(取消)，剩下**吃(y，花生)V 杀(y)** 。
*   解析图第三步**吃(y，花生)****吃(阿尼尔，花生)**换人**{阿尼尔/y}** 解析，剩下**打死(阿尼尔)**。
*   解析图第四步**杀(Anil)****杀(k)** 换人 **{Anil/k}** 获得解析，剩下**活着(Anil)** 。
*   在解析图的最后一步**活着(Anil)** 和**活着(Anil)** 得到解析。

* * *