# 数据挖掘中的宁滨是什么？

> 原文：<https://www.javatpoint.com/what-is-binning-in-data-mining>

数据宁滨，也称为离散宁滨或桶，是一种数据预处理技术，用于减少微小观测误差的影响。这是量化的一种形式。原始数据值被划分为称为箱的小区间，然后它们被为该箱计算的一般值代替。这对于输入数据有一个缓和的效果，并且还可以减少在小数据集的情况下过度拟合的机会。

***统计数据宁滨*** 是一种将或多或少连续的数值分组到较少数量的“箱”中的方法。它也可以用于多元统计，宁滨在几个维度上同时进行。例如，如果您有关于一组人的数据，您可能希望将他们的年龄排列成更小的年龄间隔，例如每五年一组。

宁滨可以显著提高资源利用率和模型构建响应时间，而不会显著降低模型质量。宁滨可以通过加强属性之间的关系来提高模型质量。

***【监督的宁滨】*** 是智能宁滨的一种形式，其中数据的重要特征被用于确定箱边界。在监督宁滨中，通过考虑与目标的联合分布的单预测器决策树来识别箱边界。监督宁滨可以用于数字和分类属性。

### 图像数据处理

在图像处理的上下文中，宁滨是将一簇像素组合成单个像素的过程。这样，在 2x2 宁滨中，4 个像素的阵列变成单个更大的像素，减少了像素的总数。

尽管与信息丢失有关，但这种聚合减少了要处理的数据量，便于分析。例如，宁滨数据也可以减少读取噪声对处理图像的影响(以较低的分辨率为代价)。

### 为什么使用宁滨？

宁滨或离散化用于将连续或数值变量转换为分类特征。连续变量的宁滨引入了非线性并倾向于改善模型的性能。它还可以用来识别缺失值或异常值。

### 宁滨数据的目的是什么？

宁滨，也称为离散化，是一种减少连续和离散数据基数的技术。宁滨将相关值组合在一起，以减少不同值的数量。

### 绑定示例

直方图是宁滨用来观察潜在分布的数据的一个例子。为了便于可视化，它们通常出现在一维空间和相等的间隔中。

当质谱(MS)或核磁共振(NMR)实验的光谱维度中的小仪器偏移将被错误地解释为代表不同的成分时，当数据分布图的集合经受模式识别分析时，可以使用数据宁滨。解决这个问题的一个简单方法是使用宁滨技术。光谱的分辨率被降低到足够的程度，以确保给定的峰保留在其仓中，尽管分析之间的光谱偏移很小。

例如，在核磁共振中，化学位移轴可能会被怀疑和粗略入库，而在质谱中，光谱精度可能会四舍五入到整数原子质量单位值。此外，一些数码相机系统结合了自动像素宁滨功能，以提高图像对比度。

宁滨还被用于机器学习，以加速决策树增强方法，用于微软的 LightGBM 和 scikit-learn 的基于直方图的梯度增强分类树等算法中的监督分类和回归。

### 你如何看待宁滨数据？

有两种方法可以将数据分成面元和宁滨数据:

**1。等频率宁滨:**仓具有相同的频率。

例如，等频率:

**输入:**【5、10、11、13、15、35、50、55、72、92、204、215】

**输出:**

[5, 10, 11, 13]

[15, 35, 50, 55]

[72, 92, 204, 215]

**2。等宽宁滨:**仓的宽度相等，每个仓的范围定义为[最小+ 2w]，[最小+ 2w] …。[最小值+最大值]其中 w =(最大值-最小值)/(箱数)。

例如，等宽:

**输入:**【5、10、11、13、15、35、50、55、72、92、204、215】

**输出:**

[5, 10, 11, 13, 15, 35, 50, 55, 72]

[92]

[204, 215]

### 宁滨技术的实现

**下面的代码展示了宁滨技术的实现。**

```

# equal frequency
def equifreq(arr1, m):   
    a = len(arr1)
    n = int(a / m)
    for i in range(0, m):
        arr = []
        for j in range(i * n, (i + 1) * n):
            if j >= a:
                break
            arr = arr + [arr1[j]]
        print(arr)

# equal width
def equiwidth(arr1, m):
    a = len(arr1)
    w = int((max(arr1) - min(arr1)) / m)
    min1 = min(arr1)
    arr = []
    for i in range(0, m + 1):
        arr = arr + [min1 + w * i]
    arri=[]

    for i in range(0, m):
        temp = []
        for j in arr1:
            if j >= arr[i] and j <= arr[i+1]:
                temp += [j]
        arri += [temp]
    print(arri)

# data to be binned
data = [5, 10, 11, 13, 15, 35, 50, 55, 72, 92, 204, 215]

# no of bins
m = 3

print("equal frequency binning")
equifreq(data, m)

print("\n\nequal width binning")
equiwidth(data, 3)

```

**输出**

上面的代码给出了以下输出。

```
Equal frequency binning
[5, 10, 11, 13]
[15, 35, 50, 55]
[72, 92, 204, 215]

Equal width binning
[[5, 10, 11, 13, 15, 35, 50, 55, 72], [92], [204, 215]] 

```

* * *