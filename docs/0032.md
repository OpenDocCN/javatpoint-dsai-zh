# 一阶逻辑中的知识工程

> 原文:[https://www . javatpoint . com/ai-knowledge-engineering-in-order-logic](https://www.javatpoint.com/ai-knowledge-engineering-in-first-order-logic)

## 什么是知识工程？

用一阶逻辑构造知识库的过程称为知识工程。在**知识工程**中，调查特定领域，学习该领域的重要概念，并生成对象的正式表示的人被称为**知识工程**。

在本主题中，我们将了解电子电路领域中的知识工程过程，这是我们已经熟悉的。这种方式主要适用于创建**专用知识库**。

## 知识工程过程:

以下是知识工程过程的一些主要步骤。使用这些步骤，我们将开发一个知识库，该知识库将允许我们推理数字电路(**一位全加器**)，如下所示

![Knowledge Engineering in First-order logic](../Images/3dc1ac5a1e2b477bb414f0374a3c9ea9.png)

### 1.确定任务:

这个过程的第一步是识别任务，对于数字电路来说，有各种推理任务。

在第一级或最高级别，我们将检查电路的功能:

*   **电路添加是否合适？**
*   **如果所有输入都为高电平，门 A2 的输出会是什么？**

在第二个层次，我们将检查电路结构细节，例如:

*   **第一个输入端接哪一个门？**
*   **电路是否有反馈回路？**

### 2.汇集相关知识:

第二步，我们将汇集数字电路所需的相关知识。因此，对于数字电路，我们需要具备以下知识:

*   逻辑电路由线和门组成。
*   信号通过导线流到门的输入端，每个门产生相应的输出，该输出进一步流动。
*   在这个逻辑电路中，使用了四种类型的门: **AND，OR，XOR 和 NOT** 。
*   所有这些门都有一个输出端和两个输入端(非门除外，它有一个输入端)。

### 3.决定词汇:

该过程的下一步是选择函数、谓词和常数来表示电路、端子、信号和门。首先，我们将把这些门彼此区分开来，并与其他物体区分开来。每个门都表示为一个对象，该对象由一个常数命名，例如，**门(X1)** 。每个门的功能由门的类型决定，门的类型被视为常数，如**与、“或”、“异或”或“非”**。电路将由一个谓词来标识:**电路(C1)** 。

对于终端，我们将使用谓词:**终端(x)** 。

对于门输入，我们将使用函数 **In(1，X1)** 来表示门的第一个输入端，对于输出端，我们将使用 **Out (1，X1)** 。

函数 **Arity(c，I，j)** 用于表示电路 c 有 I 输入，j 输出。

门之间的连通性可以用谓词 **Connect(Out(1，X1)，In(1，X1))** 来表示。

我们使用一元谓词 **On (t)** ，如果终端的信号为 On，则为真。

### 4.编码该领域的一般知识:

为了对逻辑电路的一般知识进行编码，我们需要一些以下规则:

*   如果两个端子相连，则它们具有相同的输入信号，可以表示为:

```

∀  t1, t2 Terminal (t1) ∧ Terminal (t2) ∧ Connect (t1, t2) → Signal (t1) = Signal (2). 

```

*   每个端子上的信号值为 0 或 1，表示为:

```

∀  t Terminal (t) →Signal (t) = 1 ∨Signal (t) = 0.

```

*   连接谓词是可交换的:

```

∀  t1, t2 Connect(t1, t2)  →  Connect (t2, t1). 	

```

*   闸门类型的表示:

```

∀  g Gate(g) ∧ r = Type(g) → r = OR ∨r = AND ∨r = XOR ∨r = NOT. 

```

*   当且仅当与门的任何输入为零时，与门的输出将为零。

```

∀  g Gate(g) ∧ Type(g) = AND →Signal (Out(1, g))= 0 ⇔  ∃n Signal (In(n, g))= 0\. 

```

*   当且仅当“或”门的任何输入为 1 时，“或”门的输出为 1:

```

∀  g Gate(g) ∧ Type(g) = OR → Signal (Out(1, g))= 1 ⇔  ∃n Signal (In(n, g))= 1 

```

*   当且仅当异或门的输入不同时，异或门的输出为 1:

```

∀  g Gate(g) ∧ Type(g) = XOR → Signal (Out(1, g)) = 1 ⇔  Signal (In(1, g)) ≠ Signal (In(2, g)).

```

*   “非”门的输出是其输入的反相:

```

∀  g Gate(g) ∧ Type(g) = NOT →   Signal (In(1, g)) ≠ Signal (Out(1, g)).

```

*   上述电路中的所有门都有两个输入和一个输出(非门除外)。

```

∀  g Gate(g) ∧ Type(g) = NOT →   Arity(g, 1, 1) 
∀  g Gate(g) ∧ r =Type(g)  ∧ (r= AND ∨r= OR ∨r= XOR) →  Arity (g, 2, 1). 

```

*   所有的门都是逻辑电路:

```

∀  g Gate(g) → Circuit (g). 

```

### 5.编码问题实例的描述:

现在我们对电路 C1 问题进行编码，首先对电路及其门元件进行分类。如果关于问题的本体论已经被思考过，这一步就很容易了。这一步包括编写概念实例的简单原子句子，这就是所谓的本体。

对于给定的 C1 电路，我们可以用原子句子对问题实例进行编码，如下所示:

因为在电路中有两个异或门、两个与门和一个或门，所以这些门的原子句子是:

```

For XOR gate: Type(x1)= XOR, Type(X2) = XOR
For AND gate: Type(A1) = AND, Type(A2)= AND
For OR gate: Type (O1) = OR.  

```

然后代表所有门之间的连接。

#### 注:本体论定义了存在本质的特定理论。

### 6.向推理过程提出查询并获得答案:

在这一步中，我们将找到加法器电路所有端子的所有可能的值集合。第一个查询将是:

产生 C1 电路第一个输出 0 和第二个输出 1 的输入组合应该是什么？

```

∃ i1, i2, i3 Signal (In(1, C1))=i1  ∧  Signal (In(2, C1))=i2  ∧ Signal (In(3, C1))= i3
 ∧ Signal (Out(1, C1)) =0 ∧ Signal (Out(2, C1))=1

```

### 7.调试知识库:

现在我们将调试知识库，这是整个过程的最后一步。在这一步中，我们将尝试调试知识库的问题。

在知识库中，我们可能省略了像 1 ≠ 0 这样的断言。

* * *