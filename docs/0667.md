# z 缓冲算法

> 原文:[https://www . javatpoint . com/computer-graphics-z-buffer-algorithm](https://www.javatpoint.com/computer-graphics-z-buffer-algorithm)

也称为**深度缓冲算法**。深度缓冲算法是最简单的图像空间算法。对于显示屏上的每个像素，我们记录下离观察者最近的像素内物体的深度。除了深度，我们还记录了应该显示以显示对象的强度。深度缓冲区是帧缓冲区的扩展。深度缓冲算法需要 2 个数组，每个数组的强度和深度由像素坐标(x，y)索引。

## 算法

对于屏幕上的所有像素，将深度[x，y]设置为 1.0，将强度[x，y]设置为背景值。

对于场景中的每个多边形，查找投影到屏幕上时位于多边形边界内的所有像素(x，y)。对于每个像素:

计算多边形在(x，y)处的深度 z

(b)如果 z < depth [x, y], this polygon is closer to the observer than others already recorded for this pixel. In this case, set depth [x, y] to z and intensity [x, y] to a value corresponding to polygon's shading. If instead z >深度[x，y]，则已经记录在(x，y)处的多边形比这个新多边形更靠近观察者，并且不采取任何动作。

3.毕竟多边形已经处理好了；强度数组将包含解决方案。

4.深度缓冲算法说明了所有隐藏表面算法共有的几个特征。

![Z-Buffer Algorithm](../Images/911628dcf30a107bc856dbf9bdf17b37.png)

5.首先，在这种情况下，它需要场景多边形中所有不透明表面的表示。

6.这些多边形可以是场景模型中记录的多面体面，也可以简单地表示场景中不透明的薄片。

7.该算法的一个重要特点是它使用了屏幕坐标系。在步骤 1 之前，使用矩阵乘法将场景中的所有多边形转换为屏幕坐标系。

## 深度缓冲区的局限性

1.  由于深度和强度阵列的巨大尺寸，深度缓冲算法并不总是实用的。
2.  生成 500 x 500 像素的光栅图像需要每个阵列 2，50，000 个存储位置。
3.  即使帧缓冲器可以为强度阵列提供存储器，深度阵列仍然很大。
4.  为了减少所需的存储量，可以将图像分成许多较小的图像，并依次对每个图像应用深度缓冲算法。
5.  例如，原始的 500 x 500 快速栅格可以分为 100 个栅格，每个栅格 50 x 50 像素。
6.  处理每个小栅格只需要 2500 个元素的数组，但是执行时间会增加，因为每个多边形都要处理多次。
7.  屏幕的细分并不总是增加执行时间，相反，它可以帮助减少生成图像所需的工作。这种减少是因为屏幕小区域之间的一致性。

* * *