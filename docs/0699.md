# 橙色数据挖掘

> 原文:[https://www.javatpoint.com/orange-data-mining](https://www.javatpoint.com/orange-data-mining)

Orange 是一个 C++核心对象和例程库，包含了大量标准和非标准的机器学习和数据挖掘算法。它是一个开源的数据可视化、数据挖掘和机器学习工具。Orange 是一个可脚本化的环境，用于快速原型化最新的算法和测试模式。它是核心库中存在的一组基于 python 的模块。它实现了一些执行时间并不重要的功能，并且是在 Python 中完成的。

![Orange Data Mining](../Images/1cce92a9e78fd4b795775087f050d0b4.png)

它包含了各种各样的任务，比如决策树的漂亮打印、打包和提升、属性子集等等。Orange 是一组图形小部件，利用了核心库和 orange 模块中的策略，并给出了一个不错的用户界面。这个小部件支持基于数字的通信，并且可以通过一个叫做橙色画布的可视化编程工具聚集到一个应用程序中。

所有这些共同使橙色成为数据挖掘和机器学习的独家基于组件的算法。Orange 是为数据挖掘和机器学习领域的经验丰富的用户和分析师提出的，他们希望创建和测试自己的算法，同时尽可能多地重用代码，也适合那些简单地进入该领域的人，他们可以编写简短的 python 内容进行数据分析。

Orange 的目标是为基于实验的选择、预测建模和推荐系统提供一个平台。它主要用于生物信息学、基因组研究、生物医学和教学。在教育中，它用于为生物学、生物医学和信息学学生提供更好的数据挖掘和机器学习教学方法。

## 橙色数据挖掘:

Orange 为开发人员、分析师和数据挖掘专家提供了灵活的领域。Python，新一代脚本语言和编程环境，在这里我们的数据挖掘脚本可能很容易，但很强大。Orange 采用了基于组件的快速原型制作方法。我们可以像放置乐高积木一样简单地实现我们的分析技术，甚至利用现有的算法。**为可视化编程编写 Orange 小部件脚本的 Orange 组件是什么？**。小部件利用专门设计的通信机制来传递对象，如分类器、回归器、属性列表和数据集，允许使用现代方法和技术轻松构建相当复杂的数据挖掘方案。

橙色核心对象和 Python 模块结合了大量数据挖掘任务，这些任务与评估和建模的数据预处理相去甚远。Orange 的工作原理是覆盖数据挖掘和机器学习中的技术和前景。例如，Orange 自上而下的决策树归纳是一种由许多组件组成的技术构建，任何人都可以用 python 对其进行原型化，并取代原来的组件。Orange 小部件不仅仅是为 Orange 中的特定策略提供图形界面的图形对象，它还包括一个可适应的信号机制，用于数据集、分类模型、学习者、存储评估结果的对象等对象的通信和交换。所有这些想法都是有意义的，并且一起从其他数据挖掘结构中认识到 Orange。

## 橙色部件:

Orange 小部件为我们提供了 orange 数据挖掘和机器学习技术的图形用户界面。它们包含用于数据输入和预处理、分类、回归、关联规则和聚类的小部件，一组用于模型评估和评估结果可视化的小部件，以及用于将模型导出到 PMML 的小部件。

![Orange Data Mining 1](../Images/c5fd0c79de055b58c040970605bdb6d1.png)

小部件通过令牌将数据从发送者传递到接收者小部件。例如，文件小部件输出数据对象，可以由小部件分类树学习器小部件接收。分类树构建了一个分类模型，该模型将数据发送到以图形方式显示树的小部件。评估小部件可以从文件小部件和对象获得数据集。

## 橙色脚本:

如果我们想访问 Orange 对象，那么我们需要编写我们的组件，并通过脚本设计我们的测试方案和机器学习应用程序。Python 的 Orange 接口，这是一种简单易用的脚本语言，具有清晰而强大的语法和大量附加库。与任何脚本语言一样，Python 可以用来相互测试一些想法，或者开发更详细的脚本和程序。

我们可以通过一个例子看到它是如何使用 Python 和 Orange 的，考虑一个读取数据集并打印所用属性数量的简单脚本。我们将利用来自 UCI 机器学习存储库的名为“投票”的分类数据集，该数据集记录了印度议会议员的 16 张关键选票，并为每个议员贴上党员标签:

**进口橙色**

**data1 =橙色。范例表格('投票.标签')**

**打印('实例:'，len(data1))**

**打印(属性:'，1len(data . domain . Attributes))**

在这里，我们可以看到脚本首先加载到橙色库中，读取数据文件，并打印出我们关心的内容。如果我们将这个脚本存储在 **script.py** 中，并通过 shell 命令“ **python script.py** 运行它，确保数据文件在同一个目录中，那么我们会得到

实例:543

属性:16

让我们继续我们的脚本，该脚本使用 nave 贝叶斯分类器创建的相同数据，并打印前五个实例的分类:

**型号=橙色。bayesl carrier(data 1)**

范围(5)中 I 的**:**

**打印(型号(data 1[I])**

很容易产生分类模型；我们称之为橙色？的对象(贝叶斯学习器)并给它数据集。当给定的实例返回可能的类的标签时，它返回另一个对象(朴素贝叶斯分类器)。这里我们可以看到这部分脚本的输出:

**inc**

**inc**

**inc**

**bj**

**bj**

在这里，我们需要发现什么是正确的分类；我们可以打印五个实例的原始标签:

范围(5)中 I 的**:**

**打印(型号(data1[i])、‘原来’，数据[i]。getclass()**

我们所涉及的是朴素贝叶斯分类器对第三种情况进行了错误分类:

**inc 最初 inc**

**inc 最初 inc**

**inc 原 bjp**

**bjp 原 bjp**

**bjp 原 bjp**

在 Orange 中实现的所有分类器都是概率性的。例如，他们假设类概率。所以在朴素贝叶斯分类器中，我们可能会关心我们在第三种情况下错过了多少:

**n =模型(data1[2]，橙色。获取概率)**

**打印数据，domain.classVar.values[0]，':'，n[0]**

这里我们认识到 Python 的索引从 0 开始，当使用参数 **orange 调用分类器时，分类模型返回一个概率向量。-获取概率**。我们的模型估计一家公司的概率非常高:

**Inc : 0.878529638542**

* * *